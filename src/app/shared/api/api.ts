/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all categories
     * @param includeEmpty (optional) If set to true the returned category list will include categories without datasets
     * @return A list of all categories
     */
    getAll(includeEmpty: boolean | null | undefined): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/Category?";
        if (includeEmpty !== undefined && includeEmpty !== null)
            url_ += "includeEmpty=" + encodeURIComponent("" + includeEmpty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Category[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(<any>null);
    }

    /**
     * Create a new category
     * @param request The category to create
     * @return The created category
     */
    post(request: CategoryCreateRequest): Observable<Category> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Category>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(<any>null);
    }

    /**
     * Update category
     * @param request The category to update
     * @return The updated category Id
     */
    put(request: CategoryUpdateRequest): Observable<Category> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<Category>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(<any>null);
    }

    /**
     * Get a category by id
     * @param id The id of the category to get
     * @return The category
     */
    get(id: string): Observable<Category> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Category>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(<any>null);
    }

    /**
     * Delete a category
     * @param id The id of the category to delete
     */
    delete(id: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DataContractClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all data contracts
     * @return All data contracts
     */
    getAll(): Observable<DataContract[]> {
        let url_ = this.baseUrl + "/api/DataContract";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataContract[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataContract[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DataContract[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataContract.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataContract[]>(<any>null);
    }

    /**
     * Create a new data contract
     * @param request The data contract to create
     * @return The created data contract
     */
    post(request: DataContractCreateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/DataContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Update a data contract
     * @param request The data contract to update
     * @return The updated data contract
     */
    put(request: DataContractUpdateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/DataContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Delete a data contract
     * @param id (optional) The id of the data contract to delete
     */
    delete(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/DataContract?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a data contract
     * @param id The id of the data contract to get
     * @return A data contract
     */
    get(id: string): Observable<DataContract> {
        let url_ = this.baseUrl + "/api/DataContract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DataContract>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataContract>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DataContract> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataContract.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataContract>(<any>null);
    }

    /**
     * Get all data contracts for a dataset
     * @param id The id of the dataset to get data contracts for
     * @return A list of data contracts
     */
    getByDatasetId(id: string): Observable<DataContract[]> {
        let url_ = this.baseUrl + "/api/DataContract/bydataset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDatasetId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDatasetId(<any>response_);
                } catch (e) {
                    return <Observable<DataContract[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataContract[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByDatasetId(response: HttpResponseBase): Observable<DataContract[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataContract.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataContract[]>(<any>null);
    }

    /**
     * Get all data contracts for a data source
     * @param id The id of the data source to get data contracts for
     * @return A list of data contracts
     */
    getByDataSourceId(id: string): Observable<DataContract[]> {
        let url_ = this.baseUrl + "/api/DataContract/bydatasource/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDataSourceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDataSourceId(<any>response_);
                } catch (e) {
                    return <Observable<DataContract[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataContract[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByDataSourceId(response: HttpResponseBase): Observable<DataContract[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataContract.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataContract[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DatasetAccessClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get a dataset access list
     * @param id The id of the dataset to get the access list for
     * @return A dataset access list
     */
    getAccessList(id: string): Observable<DatasetAccessList> {
        let url_ = this.baseUrl + "/api/dataset/{id}/access";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessList(<any>response_);
                } catch (e) {
                    return <Observable<DatasetAccessList>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetAccessList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccessList(response: HttpResponseBase): Observable<DatasetAccessList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatasetAccessList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetAccessList>(<any>null);
    }

    addReadAccessMember(datasetId: string, accessMemberRequest: AddDatasetAccessMemberRequestDto): Observable<DataAccessEntry> {
        let url_ = this.baseUrl + "/api/dataset/{datasetId}/access/read";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(accessMemberRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddReadAccessMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddReadAccessMember(<any>response_);
                } catch (e) {
                    return <Observable<DataAccessEntry>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataAccessEntry>><any>_observableThrow(response_);
        }));
    }

    protected processAddReadAccessMember(response: HttpResponseBase): Observable<DataAccessEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataAccessEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataAccessEntry>(<any>null);
    }

    addWriteAccessMember(datasetId: string, accessMemberRequest: AddDatasetAccessMemberRequestDto): Observable<DataAccessEntry> {
        let url_ = this.baseUrl + "/api/dataset/{datasetId}/access/write";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(accessMemberRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWriteAccessMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWriteAccessMember(<any>response_);
                } catch (e) {
                    return <Observable<DataAccessEntry>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataAccessEntry>><any>_observableThrow(response_);
        }));
    }

    protected processAddWriteAccessMember(response: HttpResponseBase): Observable<DataAccessEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataAccessEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataAccessEntry>(<any>null);
    }

    removeReadDataAccessMember(datasetId: string, memberId: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/dataset/{datasetId}/access/{memberId}/read";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
        if (memberId === undefined || memberId === null)
            throw new Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveReadDataAccessMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveReadDataAccessMember(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveReadDataAccessMember(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    removeWriteDataAccessMember(datasetId: string, memberId: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/dataset/{datasetId}/access/{memberId}/write";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
        if (memberId === undefined || memberId === null)
            throw new Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveWriteDataAccessMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveWriteDataAccessMember(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveWriteDataAccessMember(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(search: string | null | undefined): Observable<AdSearchResult[]> {
        let url_ = this.baseUrl + "/api/dataset/access?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<AdSearchResult[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdSearchResult[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<AdSearchResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdSearchResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdSearchResult[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DatasetClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get a dataset
     * @param id The id of the dataset to get
     * @return A dataset
     */
    findById(id: string): Observable<Dataset> {
        let url_ = this.baseUrl + "/api/Dataset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindById(<any>response_);
                } catch (e) {
                    return <Observable<Dataset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dataset>><any>_observableThrow(response_);
        }));
    }

    protected processFindById(response: HttpResponseBase): Observable<Dataset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dataset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dataset>(<any>null);
    }

    /**
     * Get all datasets
     * @return A list of dataset summaries
     */
    getAll(): Observable<Dataset[]> {
        let url_ = this.baseUrl + "/api/Dataset";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Dataset[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dataset[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Dataset[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dataset.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dataset[]>(<any>null);
    }

    /**
     * Create a new dataset
     * @param request The dataset to create
     * @return The created dataset
     */
    post(request: DatasetCreateRequest): Observable<Dataset> {
        let url_ = this.baseUrl + "/api/Dataset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Dataset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dataset>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Dataset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dataset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dataset>(<any>null);
    }

    /**
     * Update a dataset
     * @param request The dataset to update
     * @return The updated dataset
     */
    put(request: DatasetUpdateRequest): Observable<Dataset> {
        let url_ = this.baseUrl + "/api/Dataset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<Dataset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dataset>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<Dataset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dataset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dataset>(<any>null);
    }

    /**
     * (Soft) Delete a dataset
     * @param request The id of the dataset to delete
     */
    delete(request: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Dataset/{request}";
        if (request === undefined || request === null)
            throw new Error("The parameter 'request' must be defined.");
        url_ = url_.replace("{request}", encodeURIComponent("" + request));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a list of datasets in a given category
     * @param request The search request
     * @return A list of dataset summaries
     */
    getByCategory(request: DatasetSearchByCategoryRequest): Observable<DatasetSummary[]> {
        let url_ = this.baseUrl + "/api/Dataset/search/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCategory(<any>response_);
                } catch (e) {
                    return <Observable<DatasetSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByCategory(response: HttpResponseBase): Observable<DatasetSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DatasetSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetSummary[]>(<any>null);
    }

    /**
     * Search for datasets using a search term
     * @param request The search request
     * @return A list of dataset summaries
     */
    getBySearchTerm(request: DatasetSearchByTermRequest): Observable<DatasetSummary[]> {
        let url_ = this.baseUrl + "/api/Dataset/search/term";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySearchTerm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySearchTerm(<any>response_);
                } catch (e) {
                    return <Observable<DatasetSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBySearchTerm(response: HttpResponseBase): Observable<DatasetSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DatasetSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetSummary[]>(<any>null);
    }

    /**
     * Search for datasets using a search term
     * @param request The search request
     * @return A list of dataset names
     */
    getNameBySearchTerm(request: DatasetSearchByTermRequest): Observable<Dataset[]> {
        let url_ = this.baseUrl + "/api/Dataset/search/predictive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNameBySearchTerm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNameBySearchTerm(<any>response_);
                } catch (e) {
                    return <Observable<Dataset[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dataset[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNameBySearchTerm(response: HttpResponseBase): Observable<Dataset[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dataset.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dataset[]>(<any>null);
    }

    /**
     * Get the location path for a dataset
     * @param request The location request
     * @return The location path
     */
    getDatasetLocation(request: DatasetLocationRequest): Observable<DatasetLocation> {
        let url_ = this.baseUrl + "/api/Dataset/location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatasetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatasetLocation(<any>response_);
                } catch (e) {
                    return <Observable<DatasetLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetLocation>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatasetLocation(response: HttpResponseBase): Observable<DatasetLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatasetLocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetLocation>(<any>null);
    }

    /**
     * Get the lineage of a dataset
     * @param id The id of the dataset
     * @return A lineage model with source and sink transformations
     */
    getLineage(id: string): Observable<LineageDataset> {
        let url_ = this.baseUrl + "/api/Dataset/lineage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineage(<any>response_);
                } catch (e) {
                    return <Observable<LineageDataset>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineageDataset>><any>_observableThrow(response_);
        }));
    }

    protected processGetLineage(response: HttpResponseBase): Observable<LineageDataset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LineageDataset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineageDataset>(<any>null);
    }

    /**
     * Given an id of a dataset in raw, this endpoint will return an unsaved copy almost ready for stock
     * @param id Id for dataset in raw
     * @return The stock copy
     */
    copyDatasetInRaw(id: string): Observable<Dataset> {
        let url_ = this.baseUrl + "/api/Dataset/promote/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyDatasetInRaw(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyDatasetInRaw(<any>response_);
                } catch (e) {
                    return <Observable<Dataset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dataset>><any>_observableThrow(response_);
        }));
    }

    protected processCopyDatasetInRaw(response: HttpResponseBase): Observable<Dataset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dataset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dataset>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DatasetGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all dataset groups
     * @return A list of all dataset groups
     */
    getAll(): Observable<DatasetGroup[]> {
        let url_ = this.baseUrl + "/api/DatasetGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DatasetGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DatasetGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DatasetGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetGroup[]>(<any>null);
    }

    /**
     * Create a new dataset group
     * @param request The dataset group to create
     * @return The created dataset group
     */
    post(request: DatasetGroupCreateRequest): Observable<DatasetGroup> {
        let url_ = this.baseUrl + "/api/DatasetGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<DatasetGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetGroup>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<DatasetGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatasetGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetGroup>(<any>null);
    }

    /**
     * Update a dataset group
     * @param request The dataset group to update
     * @return The updated dataset group
     */
    put(request: DatasetGroupUpdateRequest): Observable<DatasetGroup> {
        let url_ = this.baseUrl + "/api/DatasetGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<DatasetGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetGroup>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<DatasetGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatasetGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetGroup>(<any>null);
    }

    /**
     * Delete a category
     * @param id (optional) The id of the category to delete
     */
    delete(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/DatasetGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a dataset group by id
     * @param id The id of the dataset group to get
     * @return The dataset group
     */
    get(id: string): Observable<DatasetGroup> {
        let url_ = this.baseUrl + "/api/DatasetGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DatasetGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetGroup>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DatasetGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DatasetGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetGroup>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DatasetMapClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all datasets
     * @return A list of dataset summaries
     */
    getDatasetMap(): Observable<DatasetMap[]> {
        let url_ = this.baseUrl + "/api/DatasetMap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatasetMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatasetMap(<any>response_);
                } catch (e) {
                    return <Observable<DatasetMap[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatasetMap[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatasetMap(response: HttpResponseBase): Observable<DatasetMap[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DatasetMap.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatasetMap[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DataSourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all data sources
     * @return A list of all data sources
     */
    getAll(): Observable<DataSource[]> {
        let url_ = this.baseUrl + "/api/DataSource";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DataSource[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSource[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DataSource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataSource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSource[]>(<any>null);
    }

    /**
     * Create a new data source
     * @param request The data source to create
     * @return The created data source
     */
    post(request: DataSourceCreateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/DataSource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Update data source
     * @param request The data source to create
     * @return The created data source
     */
    put(request: DataSourceUpdateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/DataSource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Delete a data source
     * @param id (optional) The id of the data source to delete
     */
    delete(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/DataSource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a data source by id
     * @param id The id of the data source to get
     * @return The category
     */
    get(id: string): Observable<DataSource> {
        let url_ = this.baseUrl + "/api/DataSource/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DataSource>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSource>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DataSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSource>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all durations
     * @return A list of all durations
     */
    getAll(): Observable<Duration[]> {
        let url_ = this.baseUrl + "/api/Duration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Duration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Duration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Duration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Duration.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Duration[]>(<any>null);
    }

    /**
     * Create a new duration
     * @param request The duration to create
     * @return The created duration
     */
    post(request: DurationCreateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Duration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Update duration
     * @param request The duration to create
     * @return The created duration
     */
    put(request: DurationUpdateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Duration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Delete a Duration
     * @param id (optional) The id of the duration to delete
     */
    delete(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Duration?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a duration by id
     * @param id The id of the duration to get
     * @return The duration
     */
    get(id: string): Observable<Duration> {
        let url_ = this.baseUrl + "/api/Duration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Duration>><any>_observableThrow(e);
                }
            } else
                return <Observable<Duration>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Duration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Duration.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Duration>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GeneralClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get sort types
     * @return A list of sort types
     */
    getSortTypeValues(): Observable<Enum[]> {
        let url_ = this.baseUrl + "/api/General/sorttype";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortTypeValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortTypeValues(<any>response_);
                } catch (e) {
                    return <Observable<Enum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortTypeValues(response: HttpResponseBase): Observable<Enum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enum[]>(<any>null);
    }

    /**
     * Get dataset statuses
     * @return A list of dataset statuses
     */
    getDatasetStatusValues(): Observable<Enum[]> {
        let url_ = this.baseUrl + "/api/General/datasetstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatasetStatusValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatasetStatusValues(<any>response_);
                } catch (e) {
                    return <Observable<Enum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatasetStatusValues(response: HttpResponseBase): Observable<Enum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enum[]>(<any>null);
    }

    /**
     * Get member roles
     * @return A list of member roles
     */
    getMemberRoles(): Observable<Enum[]> {
        let url_ = this.baseUrl + "/api/General/memberrole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberRoles(<any>response_);
                } catch (e) {
                    return <Observable<Enum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberRoles(response: HttpResponseBase): Observable<Enum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enum[]>(<any>null);
    }

    /**
     * Get confidentialities
     * @return A list of confidentialities
     */
    getConfidentialities(): Observable<Enum[]> {
        let url_ = this.baseUrl + "/api/General/confidentiality";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfidentialities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfidentialities(<any>response_);
                } catch (e) {
                    return <Observable<Enum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfidentialities(response: HttpResponseBase): Observable<Enum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enum[]>(<any>null);
    }

    /**
     * Get refinement levels
     * @return A list of refinement levels
     */
    getRefinementLevels(): Observable<Enum[]> {
        let url_ = this.baseUrl + "/api/General/refinementlevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefinementLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefinementLevels(<any>response_);
                } catch (e) {
                    return <Observable<Enum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefinementLevels(response: HttpResponseBase): Observable<Enum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enum[]>(<any>null);
    }

    /**
     * Get source types
     * @return A list of refinement levels
     */
    getSourceTypes(): Observable<Enum[]> {
        let url_ = this.baseUrl + "/api/General/sourcetypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceTypes(<any>response_);
                } catch (e) {
                    return <Observable<Enum[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enum[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSourceTypes(response: HttpResponseBase): Observable<Enum[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enum[]>(<any>null);
    }

    /**
     * Get durations
     * @return A list of durations
     * @deprecated
     */
    getDuration(): Observable<Duration[]> {
        let url_ = this.baseUrl + "/api/General/duration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDuration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDuration(<any>response_);
                } catch (e) {
                    return <Observable<Duration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Duration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDuration(response: HttpResponseBase): Observable<Duration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Duration.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Duration[]>(<any>null);
    }

    /**
     * Get hierarchies
     * @return A list of hierarchies with their child hierarchies
     * @deprecated
     */
    getHierarchies(): Observable<Hierarchy[]> {
        let url_ = this.baseUrl + "/api/General/hierarchies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHierarchies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHierarchies(<any>response_);
                } catch (e) {
                    return <Observable<Hierarchy[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Hierarchy[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHierarchies(response: HttpResponseBase): Observable<Hierarchy[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Hierarchy.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Hierarchy[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HierarchyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all hierarchies
     * @return A list of all hierarchies
     */
    getAll(): Observable<Hierarchy[]> {
        let url_ = this.baseUrl + "/api/Hierarchy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Hierarchy[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Hierarchy[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Hierarchy[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Hierarchy.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Hierarchy[]>(<any>null);
    }

    /**
     * Create a new hierarchy
     * @param request The hierarchy to create
     * @return The created hierarchy
     */
    post(request: HierarchyCreateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Hierarchy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Update hierarchy
     * @param request The hierarchy to create
     * @return The created hierarchy
     */
    put(request: HierarchyUpdateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Hierarchy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Delete a data source
     * @param id (optional) The id of the hierarchy to delete
     */
    delete(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Hierarchy?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a hierarchy by id
     * @param id The id of the hierarchy to get
     * @return The hierarchy
     */
    get(id: string): Observable<Hierarchy> {
        let url_ = this.baseUrl + "/api/Hierarchy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Hierarchy>><any>_observableThrow(e);
                }
            } else
                return <Observable<Hierarchy>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Hierarchy> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Hierarchy.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Hierarchy>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransformationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get all transformations
     * @return A list of all transformations
     */
    getAll(): Observable<Transformation[]> {
        let url_ = this.baseUrl + "/api/Transformation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Transformation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transformation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Transformation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Transformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transformation[]>(<any>null);
    }

    /**
     * Create a new transformation
     * @param request The transformation to create
     * @return The created transformation
     */
    post(request: TransformationCreateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Transformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Update transformation
     * @param request The transformation to create
     * @return The created transformation
     */
    put(request: TransformationUpdateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Transformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Delete a transformation
     * @param id (optional) The id of the transformation to delete
     */
    delete(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Transformation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Get a transformation by id
     * @param id The id of the transformation to get
     * @return The category
     */
    get(id: string): Observable<Transformation> {
        let url_ = this.baseUrl + "/api/Transformation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Transformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transformation>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Transformation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transformation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transformation>(<any>null);
    }

    /**
     * Get transformations where the sources are the given datasets
     * @param datasets The datasets to find transformations for
     * @return A list of transformations
     */
    getByDatasets(datasets: GuidId[]): Observable<Transformation[]> {
        let url_ = this.baseUrl + "/api/Transformation/getbydatasets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(datasets);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDatasets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDatasets(<any>response_);
                } catch (e) {
                    return <Observable<Transformation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transformation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByDatasets(response: HttpResponseBase): Observable<Transformation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Transformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transformation[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get name and roles for current user
     * @return User name and roles
     */
    getUserInfo(): Observable<User> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }
}

export abstract class Created implements ICreated {
    createdDate!: Date;

    constructor(data?: ICreated) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Created {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Created' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreated {
    createdDate: Date;
}

export abstract class Entity extends Created implements IEntity {
    id!: string;
    modifiedDate!: Date;

    constructor(data?: IEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Entity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Entity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IEntity extends ICreated {
    id: string;
    modifiedDate: Date;
}

export class ReplicantEntity extends Entity implements IReplicantEntity {
    version!: number;
    originEnvironment?: string | undefined;
    originDeleted!: boolean;

    constructor(data?: IReplicantEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.version = _data["version"];
            this.originEnvironment = _data["originEnvironment"];
            this.originDeleted = _data["originDeleted"];
        }
    }

    static fromJS(data: any): ReplicantEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ReplicantEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["originEnvironment"] = this.originEnvironment;
        data["originDeleted"] = this.originDeleted;
        super.toJSON(data);
        return data; 
    }
}

export interface IReplicantEntity extends IEntity {
    version: number;
    originEnvironment?: string | undefined;
    originDeleted: boolean;
}

export class Category extends ReplicantEntity implements ICategory {
    name?: string | undefined;
    colour?: string | undefined;
    imageUri?: string | undefined;

    constructor(data?: ICategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.colour = _data["colour"];
            this.imageUri = _data["imageUri"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["colour"] = this.colour;
        data["imageUri"] = this.imageUri;
        super.toJSON(data);
        return data; 
    }
}

export interface ICategory extends IReplicantEntity {
    name?: string | undefined;
    colour?: string | undefined;
    imageUri?: string | undefined;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
}

export class CategoryCreateRequest implements ICategoryCreateRequest {
    name?: string | undefined;
    colour?: string | undefined;
    imageUri?: string | undefined;

    constructor(data?: ICategoryCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.colour = _data["colour"];
            this.imageUri = _data["imageUri"];
        }
    }

    static fromJS(data: any): CategoryCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["colour"] = this.colour;
        data["imageUri"] = this.imageUri;
        return data; 
    }
}

export interface ICategoryCreateRequest {
    name?: string | undefined;
    colour?: string | undefined;
    imageUri?: string | undefined;
}

export class CategoryUpdateRequest extends CategoryCreateRequest implements ICategoryUpdateRequest {
    id!: string;

    constructor(data?: ICategoryUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface ICategoryUpdateRequest extends ICategoryCreateRequest {
    id: string;
}

export class DataContract extends ReplicantEntity implements IDataContract {
    datasetId!: string;
    dataSourceId!: string;
    datasetContainer?: string | undefined;
    datasetLocation?: string | undefined;
    datasetStatus!: DatasetStatus;

    constructor(data?: IDataContract) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.dataSourceId = _data["dataSourceId"];
            this.datasetContainer = _data["datasetContainer"];
            this.datasetLocation = _data["datasetLocation"];
            this.datasetStatus = _data["datasetStatus"];
        }
    }

    static fromJS(data: any): DataContract {
        data = typeof data === 'object' ? data : {};
        let result = new DataContract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["dataSourceId"] = this.dataSourceId;
        data["datasetContainer"] = this.datasetContainer;
        data["datasetLocation"] = this.datasetLocation;
        data["datasetStatus"] = this.datasetStatus;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataContract extends IReplicantEntity {
    datasetId: string;
    dataSourceId: string;
    datasetContainer?: string | undefined;
    datasetLocation?: string | undefined;
    datasetStatus: DatasetStatus;
}

export enum DatasetStatus {
    Draft = 0,
    Published = 1,
    Source = 2,
}

export class DataContractCreateRequest implements IDataContractCreateRequest {
    datasetId!: string;
    dataSourceId!: string;

    constructor(data?: IDataContractCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.dataSourceId = _data["dataSourceId"];
        }
    }

    static fromJS(data: any): DataContractCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataContractCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["dataSourceId"] = this.dataSourceId;
        return data; 
    }
}

export interface IDataContractCreateRequest {
    datasetId: string;
    dataSourceId: string;
}

export class DataContractUpdateRequest extends DataContractCreateRequest implements IDataContractUpdateRequest {
    id!: string;

    constructor(data?: IDataContractUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DataContractUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataContractUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataContractUpdateRequest extends IDataContractCreateRequest {
    id: string;
}

export class DatasetAccessList implements IDatasetAccessList {
    readAccessList?: DataAccessEntry[] | undefined;
    writeAccessList?: DataAccessEntry[] | undefined;

    constructor(data?: IDatasetAccessList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["readAccessList"])) {
                this.readAccessList = [] as any;
                for (let item of _data["readAccessList"])
                    this.readAccessList!.push(DataAccessEntry.fromJS(item));
            }
            if (Array.isArray(_data["writeAccessList"])) {
                this.writeAccessList = [] as any;
                for (let item of _data["writeAccessList"])
                    this.writeAccessList!.push(DataAccessEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DatasetAccessList {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetAccessList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.readAccessList)) {
            data["readAccessList"] = [];
            for (let item of this.readAccessList)
                data["readAccessList"].push(item.toJSON());
        }
        if (Array.isArray(this.writeAccessList)) {
            data["writeAccessList"] = [];
            for (let item of this.writeAccessList)
                data["writeAccessList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDatasetAccessList {
    readAccessList?: DataAccessEntry[] | undefined;
    writeAccessList?: DataAccessEntry[] | undefined;
}

export class DataAccessEntry implements IDataAccessEntry {
    id?: string | undefined;
    name?: string | undefined;
    mail?: string | undefined;
    memberType?: string | undefined;

    constructor(data?: IDataAccessEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mail = _data["mail"];
            this.memberType = _data["memberType"];
        }
    }

    static fromJS(data: any): DataAccessEntry {
        data = typeof data === 'object' ? data : {};
        let result = new DataAccessEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mail"] = this.mail;
        data["memberType"] = this.memberType;
        return data; 
    }
}

export interface IDataAccessEntry {
    id?: string | undefined;
    name?: string | undefined;
    mail?: string | undefined;
    memberType?: string | undefined;
}

export class AddDatasetAccessMemberRequestDto implements IAddDatasetAccessMemberRequestDto {
    memberId!: string;

    constructor(data?: IAddDatasetAccessMemberRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): AddDatasetAccessMemberRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddDatasetAccessMemberRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        return data; 
    }
}

export interface IAddDatasetAccessMemberRequestDto {
    memberId: string;
}

export class AdSearchResult implements IAdSearchResult {
    id?: string | undefined;
    displayName?: string | undefined;
    mail?: string | undefined;
    type?: string | undefined;

    constructor(data?: IAdSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.mail = _data["mail"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AdSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new AdSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["mail"] = this.mail;
        data["type"] = this.type;
        return data; 
    }
}

export interface IAdSearchResult {
    id?: string | undefined;
    displayName?: string | undefined;
    mail?: string | undefined;
    type?: string | undefined;
}

export class Dataset extends ReplicantEntity implements IDataset {
    memberId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    slaDescription?: string | undefined;
    slaLink?: string | undefined;
    owner?: string | undefined;
    status!: DatasetStatus;
    confidentiality!: Confidentiality;
    refinementLevel!: RefinementLevel;
    location?: string | undefined;
    contact?: ContactInfo | undefined;
    frequency?: Duration | undefined;
    resolution?: Duration | undefined;
    sourceTransformation?: Transformation | undefined;
    hierarchy?: Hierarchy | undefined;
    dataFields?: DataField[] | undefined;
    categories?: Category[] | undefined;
    datasetChangeLogs?: DatasetChangeLog[] | undefined;
    dataSources?: DataSource[] | undefined;
    provisionStatus!: ProvisionDatasetStatusEnum;

    constructor(data?: IDataset) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.slaDescription = _data["slaDescription"];
            this.slaLink = _data["slaLink"];
            this.owner = _data["owner"];
            this.status = _data["status"];
            this.confidentiality = _data["confidentiality"];
            this.refinementLevel = _data["refinementLevel"];
            this.location = _data["location"];
            this.contact = _data["contact"] ? ContactInfo.fromJS(_data["contact"]) : <any>undefined;
            this.frequency = _data["frequency"] ? Duration.fromJS(_data["frequency"]) : <any>undefined;
            this.resolution = _data["resolution"] ? Duration.fromJS(_data["resolution"]) : <any>undefined;
            this.sourceTransformation = _data["sourceTransformation"] ? Transformation.fromJS(_data["sourceTransformation"]) : <any>undefined;
            this.hierarchy = _data["hierarchy"] ? Hierarchy.fromJS(_data["hierarchy"]) : <any>undefined;
            if (Array.isArray(_data["dataFields"])) {
                this.dataFields = [] as any;
                for (let item of _data["dataFields"])
                    this.dataFields!.push(DataField.fromJS(item));
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["datasetChangeLogs"])) {
                this.datasetChangeLogs = [] as any;
                for (let item of _data["datasetChangeLogs"])
                    this.datasetChangeLogs!.push(DatasetChangeLog.fromJS(item));
            }
            if (Array.isArray(_data["dataSources"])) {
                this.dataSources = [] as any;
                for (let item of _data["dataSources"])
                    this.dataSources!.push(DataSource.fromJS(item));
            }
            this.provisionStatus = _data["provisionStatus"];
        }
    }

    static fromJS(data: any): Dataset {
        data = typeof data === 'object' ? data : {};
        let result = new Dataset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["slaDescription"] = this.slaDescription;
        data["slaLink"] = this.slaLink;
        data["owner"] = this.owner;
        data["status"] = this.status;
        data["confidentiality"] = this.confidentiality;
        data["refinementLevel"] = this.refinementLevel;
        data["location"] = this.location;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["resolution"] = this.resolution ? this.resolution.toJSON() : <any>undefined;
        data["sourceTransformation"] = this.sourceTransformation ? this.sourceTransformation.toJSON() : <any>undefined;
        data["hierarchy"] = this.hierarchy ? this.hierarchy.toJSON() : <any>undefined;
        if (Array.isArray(this.dataFields)) {
            data["dataFields"] = [];
            for (let item of this.dataFields)
                data["dataFields"].push(item.toJSON());
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.datasetChangeLogs)) {
            data["datasetChangeLogs"] = [];
            for (let item of this.datasetChangeLogs)
                data["datasetChangeLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.dataSources)) {
            data["dataSources"] = [];
            for (let item of this.dataSources)
                data["dataSources"].push(item.toJSON());
        }
        data["provisionStatus"] = this.provisionStatus;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataset extends IReplicantEntity {
    memberId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    slaDescription?: string | undefined;
    slaLink?: string | undefined;
    owner?: string | undefined;
    status: DatasetStatus;
    confidentiality: Confidentiality;
    refinementLevel: RefinementLevel;
    location?: string | undefined;
    contact?: ContactInfo | undefined;
    frequency?: Duration | undefined;
    resolution?: Duration | undefined;
    sourceTransformation?: Transformation | undefined;
    hierarchy?: Hierarchy | undefined;
    dataFields?: DataField[] | undefined;
    categories?: Category[] | undefined;
    datasetChangeLogs?: DatasetChangeLog[] | undefined;
    dataSources?: DataSource[] | undefined;
    provisionStatus: ProvisionDatasetStatusEnum;
}

export enum Confidentiality {
    Public = 0,
    Internal = 1,
    Confidential = 2,
    StrictlyConfidential = 3,
}

export enum RefinementLevel {
    Raw = 0,
    Stock = 1,
    Refined = 2,
}

export class ContactInfo implements IContactInfo {
    name?: string | undefined;
    link?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.link = _data["link"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["link"] = this.link;
        data["email"] = this.email;
        return data; 
    }
}

export interface IContactInfo {
    name?: string | undefined;
    link?: string | undefined;
    email?: string | undefined;
}

export class Duration extends Entity implements IDuration {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IDuration) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Duration {
        data = typeof data === 'object' ? data : {};
        let result = new Duration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuration extends IEntity {
    code?: string | undefined;
    description?: string | undefined;
}

export class Transformation extends Entity implements ITransformation {
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: DatasetSummary[] | undefined;
    sinkDatasets?: DatasetSummary[] | undefined;

    constructor(data?: ITransformation) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            if (Array.isArray(_data["sourceDatasets"])) {
                this.sourceDatasets = [] as any;
                for (let item of _data["sourceDatasets"])
                    this.sourceDatasets!.push(DatasetSummary.fromJS(item));
            }
            if (Array.isArray(_data["sinkDatasets"])) {
                this.sinkDatasets = [] as any;
                for (let item of _data["sinkDatasets"])
                    this.sinkDatasets!.push(DatasetSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Transformation {
        data = typeof data === 'object' ? data : {};
        let result = new Transformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        if (Array.isArray(this.sourceDatasets)) {
            data["sourceDatasets"] = [];
            for (let item of this.sourceDatasets)
                data["sourceDatasets"].push(item.toJSON());
        }
        if (Array.isArray(this.sinkDatasets)) {
            data["sinkDatasets"] = [];
            for (let item of this.sinkDatasets)
                data["sinkDatasets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITransformation extends IEntity {
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: DatasetSummary[] | undefined;
    sinkDatasets?: DatasetSummary[] | undefined;
}

export class DatasetSummary extends Entity implements IDatasetSummary {
    name?: string | undefined;
    description?: string | undefined;
    status!: DatasetStatus;
    confidentiality!: Confidentiality;
    categories?: Category[] | undefined;

    constructor(data?: IDatasetSummary) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.confidentiality = _data["confidentiality"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(Category.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DatasetSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["confidentiality"] = this.confidentiality;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetSummary extends IEntity {
    name?: string | undefined;
    description?: string | undefined;
    status: DatasetStatus;
    confidentiality: Confidentiality;
    categories?: Category[] | undefined;
}

export class Hierarchy extends Entity implements IHierarchy {
    name?: string | undefined;
    description?: string | undefined;
    parentHierarchyId?: string | undefined;
    childHierarchies?: Hierarchy[] | undefined;

    constructor(data?: IHierarchy) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.parentHierarchyId = _data["parentHierarchyId"];
            if (Array.isArray(_data["childHierarchies"])) {
                this.childHierarchies = [] as any;
                for (let item of _data["childHierarchies"])
                    this.childHierarchies!.push(Hierarchy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Hierarchy {
        data = typeof data === 'object' ? data : {};
        let result = new Hierarchy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["parentHierarchyId"] = this.parentHierarchyId;
        if (Array.isArray(this.childHierarchies)) {
            data["childHierarchies"] = [];
            for (let item of this.childHierarchies)
                data["childHierarchies"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IHierarchy extends IEntity {
    name?: string | undefined;
    description?: string | undefined;
    parentHierarchyId?: string | undefined;
    childHierarchies?: Hierarchy[] | undefined;
}

export class DataField extends Entity implements IDataField {
    name?: string | undefined;
    type?: string | undefined;
    description?: string | undefined;
    format?: string | undefined;
    validation?: string | undefined;

    constructor(data?: IDataField) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.format = _data["format"];
            this.validation = _data["validation"];
        }
    }

    static fromJS(data: any): DataField {
        data = typeof data === 'object' ? data : {};
        let result = new DataField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["description"] = this.description;
        data["format"] = this.format;
        data["validation"] = this.validation;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataField extends IEntity {
    name?: string | undefined;
    type?: string | undefined;
    description?: string | undefined;
    format?: string | undefined;
    validation?: string | undefined;
}

export class DatasetChangeLog extends Created implements IDatasetChangeLog {
    member?: Member | undefined;

    constructor(data?: IDatasetChangeLog) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DatasetChangeLog {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetChangeLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetChangeLog extends ICreated {
    member?: Member | undefined;
}

export class Member extends Entity implements IMember {
    name?: string | undefined;
    email?: string | undefined;
    memberRole!: Role;

    constructor(data?: IMember) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.memberRole = _data["memberRole"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["memberRole"] = this.memberRole;
        super.toJSON(data);
        return data; 
    }
}

export interface IMember extends IEntity {
    name?: string | undefined;
    email?: string | undefined;
    memberRole: Role;
}

export enum Role {
    Admin = 0,
    DataSteward = 1,
    User = 2,
}

export class DataSource extends ReplicantEntity implements IDataSource {
    name?: string | undefined;
    description?: string | undefined;
    contactInfo?: string | undefined;
    sourceType!: SourceType;

    constructor(data?: IDataSource) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.contactInfo = _data["contactInfo"];
            this.sourceType = _data["sourceType"];
        }
    }

    static fromJS(data: any): DataSource {
        data = typeof data === 'object' ? data : {};
        let result = new DataSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["contactInfo"] = this.contactInfo;
        data["sourceType"] = this.sourceType;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataSource extends IReplicantEntity {
    name?: string | undefined;
    description?: string | undefined;
    contactInfo?: string | undefined;
    sourceType: SourceType;
}

export enum SourceType {
    DataPlatform = 0,
    Internal = 1,
    External = 2,
}

export enum ProvisionDatasetStatusEnum {
    Pending = 0,
    Succeeded = 1,
    Failed = 2,
}

export class DatasetCreateRequest implements IDatasetCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    slaDescription?: string | undefined;
    slaLink?: string | undefined;
    owner?: string | undefined;
    status!: DatasetStatus;
    confidentiality!: Confidentiality;
    refinementLevel!: RefinementLevel;
    location?: string | undefined;
    hierarchy?: GuidId | undefined;
    categories?: GuidId[] | undefined;
    dataSources?: GuidId[] | undefined;
    frequency?: DurationUpsertRequest | undefined;
    resolution?: DurationUpsertRequest | undefined;
    sourceTransformation?: SourceTransformationUpsertRequest | undefined;
    dataFields?: DataFieldUpsertRequest[] | undefined;

    constructor(data?: IDatasetCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.slaDescription = _data["slaDescription"];
            this.slaLink = _data["slaLink"];
            this.owner = _data["owner"];
            this.status = _data["status"];
            this.confidentiality = _data["confidentiality"];
            this.refinementLevel = _data["refinementLevel"];
            this.location = _data["location"];
            this.hierarchy = _data["hierarchy"] ? GuidId.fromJS(_data["hierarchy"]) : <any>undefined;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(GuidId.fromJS(item));
            }
            if (Array.isArray(_data["dataSources"])) {
                this.dataSources = [] as any;
                for (let item of _data["dataSources"])
                    this.dataSources!.push(GuidId.fromJS(item));
            }
            this.frequency = _data["frequency"] ? DurationUpsertRequest.fromJS(_data["frequency"]) : <any>undefined;
            this.resolution = _data["resolution"] ? DurationUpsertRequest.fromJS(_data["resolution"]) : <any>undefined;
            this.sourceTransformation = _data["sourceTransformation"] ? SourceTransformationUpsertRequest.fromJS(_data["sourceTransformation"]) : <any>undefined;
            if (Array.isArray(_data["dataFields"])) {
                this.dataFields = [] as any;
                for (let item of _data["dataFields"])
                    this.dataFields!.push(DataFieldUpsertRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DatasetCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["slaDescription"] = this.slaDescription;
        data["slaLink"] = this.slaLink;
        data["owner"] = this.owner;
        data["status"] = this.status;
        data["confidentiality"] = this.confidentiality;
        data["refinementLevel"] = this.refinementLevel;
        data["location"] = this.location;
        data["hierarchy"] = this.hierarchy ? this.hierarchy.toJSON() : <any>undefined;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.dataSources)) {
            data["dataSources"] = [];
            for (let item of this.dataSources)
                data["dataSources"].push(item.toJSON());
        }
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["resolution"] = this.resolution ? this.resolution.toJSON() : <any>undefined;
        data["sourceTransformation"] = this.sourceTransformation ? this.sourceTransformation.toJSON() : <any>undefined;
        if (Array.isArray(this.dataFields)) {
            data["dataFields"] = [];
            for (let item of this.dataFields)
                data["dataFields"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDatasetCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    slaDescription?: string | undefined;
    slaLink?: string | undefined;
    owner?: string | undefined;
    status: DatasetStatus;
    confidentiality: Confidentiality;
    refinementLevel: RefinementLevel;
    location?: string | undefined;
    hierarchy?: GuidId | undefined;
    categories?: GuidId[] | undefined;
    dataSources?: GuidId[] | undefined;
    frequency?: DurationUpsertRequest | undefined;
    resolution?: DurationUpsertRequest | undefined;
    sourceTransformation?: SourceTransformationUpsertRequest | undefined;
    dataFields?: DataFieldUpsertRequest[] | undefined;
}

export class GuidId implements IGuidId {
    id!: string;

    constructor(data?: IGuidId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GuidId {
        data = typeof data === 'object' ? data : {};
        let result = new GuidId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IGuidId {
    id: string;
}

export class NullableGuidId implements INullableGuidId {
    id?: string | undefined;

    constructor(data?: INullableGuidId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NullableGuidId {
        data = typeof data === 'object' ? data : {};
        let result = new NullableGuidId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface INullableGuidId {
    id?: string | undefined;
}

export class DurationUpsertRequest extends NullableGuidId implements IDurationUpsertRequest {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IDurationUpsertRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DurationUpsertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DurationUpsertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IDurationUpsertRequest extends INullableGuidId {
    code?: string | undefined;
    description?: string | undefined;
}

export class SourceTransformationUpsertRequest implements ISourceTransformationUpsertRequest {
    id?: string | undefined;
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: GuidId[] | undefined;

    constructor(data?: ISourceTransformationUpsertRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            if (Array.isArray(_data["sourceDatasets"])) {
                this.sourceDatasets = [] as any;
                for (let item of _data["sourceDatasets"])
                    this.sourceDatasets!.push(GuidId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SourceTransformationUpsertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SourceTransformationUpsertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        if (Array.isArray(this.sourceDatasets)) {
            data["sourceDatasets"] = [];
            for (let item of this.sourceDatasets)
                data["sourceDatasets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISourceTransformationUpsertRequest {
    id?: string | undefined;
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: GuidId[] | undefined;
}

export class DataFieldUpsertRequest extends NullableGuidId implements IDataFieldUpsertRequest {
    name?: string | undefined;
    type?: string | undefined;
    description?: string | undefined;
    format?: string | undefined;
    validation?: string | undefined;

    constructor(data?: IDataFieldUpsertRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.format = _data["format"];
            this.validation = _data["validation"];
        }
    }

    static fromJS(data: any): DataFieldUpsertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataFieldUpsertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["description"] = this.description;
        data["format"] = this.format;
        data["validation"] = this.validation;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataFieldUpsertRequest extends INullableGuidId {
    name?: string | undefined;
    type?: string | undefined;
    description?: string | undefined;
    format?: string | undefined;
    validation?: string | undefined;
}

export class DatasetUpdateRequest extends DatasetCreateRequest implements IDatasetUpdateRequest {
    id!: string;

    constructor(data?: IDatasetUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DatasetUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetUpdateRequest extends IDatasetCreateRequest {
    id: string;
}

export abstract class DatasetSearchRequest implements IDatasetSearchRequest {
    sortType!: SortType;
    take!: number;
    pageSize!: number;
    pageIndex!: number;

    constructor(data?: IDatasetSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortType = _data["sortType"];
            this.take = _data["take"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
        }
    }

    static fromJS(data: any): DatasetSearchRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DatasetSearchRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortType"] = this.sortType;
        data["take"] = this.take;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        return data; 
    }
}

export interface IDatasetSearchRequest {
    sortType: SortType;
    take: number;
    pageSize: number;
    pageIndex: number;
}

export class DatasetSearchByCategoryRequest extends DatasetSearchRequest implements IDatasetSearchByCategoryRequest {
    categoryId!: string;

    constructor(data?: IDatasetSearchByCategoryRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): DatasetSearchByCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetSearchByCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetSearchByCategoryRequest extends IDatasetSearchRequest {
    categoryId: string;
}

export enum SortType {
    None = 0,
    ByNameAscending = 1,
    ByNameDescending = 2,
    ByCreatedDateAscending = 3,
    ByCreatedDateDescending = 4,
    ByModifiedDateAscending = 5,
    ByModifiedDateDescending = 6,
}

export class DatasetSearchByTermRequest extends DatasetSearchRequest implements IDatasetSearchByTermRequest {
    searchTerm?: string | undefined;

    constructor(data?: IDatasetSearchByTermRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchTerm = _data["searchTerm"];
        }
    }

    static fromJS(data: any): DatasetSearchByTermRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetSearchByTermRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetSearchByTermRequest extends IDatasetSearchRequest {
    searchTerm?: string | undefined;
}

export class DatasetLocation implements IDatasetLocation {
    location?: string | undefined;

    constructor(data?: IDatasetLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): DatasetLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        return data; 
    }
}

export interface IDatasetLocation {
    location?: string | undefined;
}

export class DatasetLocationRequest implements IDatasetLocationRequest {
    name?: string | undefined;
    hierarchy?: NullableGuidId | undefined;

    constructor(data?: IDatasetLocationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.hierarchy = _data["hierarchy"] ? NullableGuidId.fromJS(_data["hierarchy"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DatasetLocationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetLocationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["hierarchy"] = this.hierarchy ? this.hierarchy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDatasetLocationRequest {
    name?: string | undefined;
    hierarchy?: NullableGuidId | undefined;
}

export class LineageDataset extends DatasetSummary implements ILineageDataset {
    sourceTransformations?: LineageTransformation[] | undefined;
    sinkTransformations?: LineageTransformation[] | undefined;

    constructor(data?: ILineageDataset) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["sourceTransformations"])) {
                this.sourceTransformations = [] as any;
                for (let item of _data["sourceTransformations"])
                    this.sourceTransformations!.push(LineageTransformation.fromJS(item));
            }
            if (Array.isArray(_data["sinkTransformations"])) {
                this.sinkTransformations = [] as any;
                for (let item of _data["sinkTransformations"])
                    this.sinkTransformations!.push(LineageTransformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LineageDataset {
        data = typeof data === 'object' ? data : {};
        let result = new LineageDataset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sourceTransformations)) {
            data["sourceTransformations"] = [];
            for (let item of this.sourceTransformations)
                data["sourceTransformations"].push(item.toJSON());
        }
        if (Array.isArray(this.sinkTransformations)) {
            data["sinkTransformations"] = [];
            for (let item of this.sinkTransformations)
                data["sinkTransformations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ILineageDataset extends IDatasetSummary {
    sourceTransformations?: LineageTransformation[] | undefined;
    sinkTransformations?: LineageTransformation[] | undefined;
}

export class LineageTransformation extends Entity implements ILineageTransformation {
    shortDescription?: string | undefined;
    description?: string | undefined;
    datasets?: LineageDataset[] | undefined;

    constructor(data?: ILineageTransformation) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets!.push(LineageDataset.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LineageTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new LineageTransformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ILineageTransformation extends IEntity {
    shortDescription?: string | undefined;
    description?: string | undefined;
    datasets?: LineageDataset[] | undefined;
}

export class DatasetGroup extends Entity implements IDatasetGroup {
    memberId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    datasets?: DatasetSummary[] | undefined;

    constructor(data?: IDatasetGroup) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets!.push(DatasetSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DatasetGroup {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetGroup extends IEntity {
    memberId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    datasets?: DatasetSummary[] | undefined;
}

export class DatasetGroupCreateRequest implements IDatasetGroupCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    datasets?: GuidId[] | undefined;

    constructor(data?: IDatasetGroupCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets!.push(GuidId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DatasetGroupCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetGroupCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDatasetGroupCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    datasets?: GuidId[] | undefined;
}

export class DatasetGroupUpdateRequest extends GuidId implements IDatasetGroupUpdateRequest {
    memberId!: string;
    name?: string | undefined;
    description?: string | undefined;
    datasets?: GuidId[] | undefined;

    constructor(data?: IDatasetGroupUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets!.push(GuidId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DatasetGroupUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetGroupUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDatasetGroupUpdateRequest extends IGuidId {
    memberId: string;
    name?: string | undefined;
    description?: string | undefined;
    datasets?: GuidId[] | undefined;
}

export class DatasetMap implements IDatasetMap {
    id!: string;
    name?: string | undefined;

    constructor(data?: IDatasetMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DatasetMap {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDatasetMap {
    id: string;
    name?: string | undefined;
}

export class DataSourceCreateRequest implements IDataSourceCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    contactInfo?: string | undefined;
    sourceType!: SourceType;

    constructor(data?: IDataSourceCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.contactInfo = _data["contactInfo"];
            this.sourceType = _data["sourceType"];
        }
    }

    static fromJS(data: any): DataSourceCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["contactInfo"] = this.contactInfo;
        data["sourceType"] = this.sourceType;
        return data; 
    }
}

export interface IDataSourceCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    contactInfo?: string | undefined;
    sourceType: SourceType;
}

export class DataSourceUpdateRequest extends DataSourceCreateRequest implements IDataSourceUpdateRequest {
    id!: string;

    constructor(data?: IDataSourceUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DataSourceUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDataSourceUpdateRequest extends IDataSourceCreateRequest {
    id: string;
}

export class DurationCreateRequest implements IDurationCreateRequest {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IDurationCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DurationCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DurationCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDurationCreateRequest {
    code?: string | undefined;
    description?: string | undefined;
}

export class DurationUpdateRequest extends DurationCreateRequest implements IDurationUpdateRequest {
    id!: string;

    constructor(data?: IDurationUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DurationUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DurationUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDurationUpdateRequest extends IDurationCreateRequest {
    id: string;
}

export class Enum implements IEnum {
    id!: number;
    description?: string | undefined;

    constructor(data?: IEnum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Enum {
        data = typeof data === 'object' ? data : {};
        let result = new Enum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data; 
    }
}

export interface IEnum {
    id: number;
    description?: string | undefined;
}

export class HierarchyCreateRequest implements IHierarchyCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    parentHierarchyId?: string | undefined;

    constructor(data?: IHierarchyCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.parentHierarchyId = _data["parentHierarchyId"];
        }
    }

    static fromJS(data: any): HierarchyCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HierarchyCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["parentHierarchyId"] = this.parentHierarchyId;
        return data; 
    }
}

export interface IHierarchyCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    parentHierarchyId?: string | undefined;
}

export class HierarchyUpdateRequest extends HierarchyCreateRequest implements IHierarchyUpdateRequest {
    id!: string;

    constructor(data?: IHierarchyUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HierarchyUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HierarchyUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IHierarchyUpdateRequest extends IHierarchyCreateRequest {
    id: string;
}

export class TransformationCreateRequest implements ITransformationCreateRequest {
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: GuidId[] | undefined;
    sinkDatasets?: GuidId[] | undefined;

    constructor(data?: ITransformationCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            if (Array.isArray(_data["sourceDatasets"])) {
                this.sourceDatasets = [] as any;
                for (let item of _data["sourceDatasets"])
                    this.sourceDatasets!.push(GuidId.fromJS(item));
            }
            if (Array.isArray(_data["sinkDatasets"])) {
                this.sinkDatasets = [] as any;
                for (let item of _data["sinkDatasets"])
                    this.sinkDatasets!.push(GuidId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransformationCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransformationCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        if (Array.isArray(this.sourceDatasets)) {
            data["sourceDatasets"] = [];
            for (let item of this.sourceDatasets)
                data["sourceDatasets"].push(item.toJSON());
        }
        if (Array.isArray(this.sinkDatasets)) {
            data["sinkDatasets"] = [];
            for (let item of this.sinkDatasets)
                data["sinkDatasets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransformationCreateRequest {
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: GuidId[] | undefined;
    sinkDatasets?: GuidId[] | undefined;
}

export class TransformationUpdateRequest extends GuidId implements ITransformationUpdateRequest {
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: GuidId[] | undefined;
    sinkDatasets?: GuidId[] | undefined;

    constructor(data?: ITransformationUpdateRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            if (Array.isArray(_data["sourceDatasets"])) {
                this.sourceDatasets = [] as any;
                for (let item of _data["sourceDatasets"])
                    this.sourceDatasets!.push(GuidId.fromJS(item));
            }
            if (Array.isArray(_data["sinkDatasets"])) {
                this.sinkDatasets = [] as any;
                for (let item of _data["sinkDatasets"])
                    this.sinkDatasets!.push(GuidId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransformationUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransformationUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        if (Array.isArray(this.sourceDatasets)) {
            data["sourceDatasets"] = [];
            for (let item of this.sourceDatasets)
                data["sourceDatasets"].push(item.toJSON());
        }
        if (Array.isArray(this.sinkDatasets)) {
            data["sinkDatasets"] = [];
            for (let item of this.sinkDatasets)
                data["sinkDatasets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITransformationUpdateRequest extends IGuidId {
    shortDescription?: string | undefined;
    description?: string | undefined;
    sourceDatasets?: GuidId[] | undefined;
    sinkDatasets?: GuidId[] | undefined;
}

export class User implements IUser {
    name?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUser {
    name?: string | undefined;
    roles?: string[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}